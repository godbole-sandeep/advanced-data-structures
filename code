#include "HashTable.h"

HashTable::HashTable(size_t initial_capacity, double max_load_factor)
	: m_storage(initial_capacity), m_maxLoadFactor(max_load_factor),
	m_size(0), m_capacity(initial_capacity) {}

std::pair<int, bool> HashTable::Insert(int key) {
	// Compute hash of the key
	size_t index = Hash(key);

	// Determine the index
	while (m_storage[index].occupied) {
		if (m_storage[index].key == key && !m_storage[index].deleted) {
			return { -1, false }; // Key already exists
		}
		index = (index + 1) % m_capacity; // Linear probing
	}

	// Insert key in the hash table
	m_storage[index] = HashItem(key, true);
	m_size++;

	// Rehash if current load factor > max load factor
	if (static_cast<double>(m_size) / m_capacity > m_maxLoadFactor) {
		Rehash();
		return Find(key);
	}

	return { index, true };
}

// Marks a key as available in the hash table; returns false if the key is not found
bool HashTable::Remove(int key) {
	// Same logic as find except difference in the 47th line
	size_t original_index = Hash(key);
	bool found = m_storage[original_index].occupied && m_storage[original_index].key == key &&
		!m_storage[original_index].deleted;
	if (found) {
		m_storage[original_index].deleted = true;
		return true;
	}

	size_t index = original_index;
	do {
		index = (index + 1) % m_capacity;
		found = m_storage[index].occupied && m_storage[index].key == key &&
			!m_storage[index].deleted;
		if (found) {
			m_storage[original_index].deleted = true;
			return true;
		}
	} while (!found && index != original_index);

	return false; // Key not found
}

// Find a key in the hash table; returns a pair with the key if found,
// otherwise 0 and false
std::pair<int, bool> HashTable::Find(int key) {
	size_t original_index = Hash(key);
	bool found = m_storage[original_index].occupied && m_storage[original_index].key == key &&
		!m_storage[original_index].deleted;
	if (found) {
		return { m_storage[original_index].key, true };
	}

	size_t index = original_index;
	do {
		index = (index + 1) % m_capacity;
		found = m_storage[index].occupied && m_storage[index].key == key &&
			!m_storage[index].deleted;
		if (found) {
			return { m_storage[index].key, true };
		}
	} while (!found && index != original_index);

	return { 0, false }; // Key not found
}

// Hash function to map a key to an index within the current capacity
size_t HashTable::Hash(int key) const {
	return key % m_capacity;
}

// Rehash the hash table by increasing the capacity and redistributing all existing buckets
void HashTable::Rehash() {
	// Increase the capacity of the hash table
	m_capacity *= 2;
	std::vector<HashItem> new_bucket(m_capacity);
	m_storage.swap(new_bucket);
	m_size = 0;

	// Redistribute existing buckets
	for (const auto& item : new_bucket) {
		if (item.occupied && !item.deleted) {
			Insert(item.key);
		}
	}
}
